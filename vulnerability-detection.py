""" ----------------------------------------------------------------------
 <copyright file="vulnerability_detection.py" company="Robert Bosch GmbH">
 2024 by Robert Bosch GmbH. All rights reserved.
 This file is property of Robert Bosch GmbH. Any unauthorized copy, use or
 distribution is an offensive act against international law and may be
 prosecuted under federal law. Its content is company confidential.
 </copyright>
 -------------------------------------------------------------------------
"""

import argparse
import json
import logging
import os
import re
import smtplib
import stat
import subprocess
import time
import xml.etree.ElementTree as ET

from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path
import requests
from packaging.specifiers import SpecifierSet
from packaging.version import Version

# Configure the logging
logging.basicConfig(level=logging.INFO,
                     format='%(asctime)s - %(levelname)s - %(message)s')

# Create a logger
logger = logging.getLogger(__name__)

def split_specifiers(specifiers):
    """
    Split the input string by commas to handle multiple specifiers.

    Parameters:
    ----------
    specifiers : str
        A string of version specifiers separated by commas

    Returns:
    -------
    list
        A list of individual version specifiers.

    Example:
    --------
    >>> split_specifiers(">=1.0.0,<2.0.0")
    ['>=1.0.0', '<2.0.0']
    >>> split_specifiers(">=1.0.0,<2.0.0,!=1.5.5")
    ['>=1.0.0', '<2.0.0', '!=1.5.5']
    >>> split_specifiers(">=1.0.0")
    ['>=1.0.0']
    """
    return specifiers.split(",")

def extract_release_version(specifier):
    """
    Extract the release version using a regular expression.

    Parameters:
    ----------
    specifier : str
        A version specifier string that contains a version number.

    Returns:
    -------
    str or None
        The extracted version number in the format "X.Y.Z".
        If no match is found, the function returns `None`.

    Example:
    --------
    >>> extract_release_version(">=1.0.0")
    '1.0.0'
    >>> extract_release_version("!=a.0.0")
    'None'
    """
    version_pattern = re.compile(r"(\d+(\.\d+)*)")
    match = version_pattern.search(specifier)
    return match.group(1) if match else None

def index_of_first_digit(s):
    """
    Return the starting index of the first digit

    Parameters:
    ----------
    s : str
        The input string in which to search for the first digit.

    Returns:
    -------
    int
        The index of the first digit found in the string.
        If no digit is found, the function returns `-1`.
    
    Example:
    --------
    >>> index_of_first_digit(">=1.0.0")
    2
    >>> index_of_first_digit(".rc")
    -1
    """
    match = re.search(r"\d+", s)
    return match.start() if match else -1

def recreate_specifier_with_release_version(specifier, release_version):
    """
    Recreate the specifier with the original operator and the release version.

    Parameters:
    ----------
    specifier : str
        The original specifier that may contain
        an operator and a pre-release version.
    
    release_version : str
        The release version that
        will replace any pre-release version in the specifier.
    Returns:
    -------
    str
        The recreated specifier with 
        the original operator and the release version.

    Example:
    --------
    >>> recreate_specifier_with_release_version(">=1.2.3-alpha", "1.2.3")
    '>=1.2.3'
    >>> recreate_specifier_with_release_version(">=1.2.3-rcc-3.2.1", "1.2.3"))
    '>=1.2.3'
    """
    ind = index_of_first_digit(specifier)
    operator = specifier[:ind] if ind != -1 else ""
    return f"{operator}{release_version}"

def filter_release_versions(specifiers):
    """
    Filter out pre-release version specifiers from a string
    and return only the stable release versions.

    Parameters:
    ----------
    specifiers : str
        A string containing one or more version specifiers,
        possibly including pre-release versions.

    Returns:
    -------
    str
        A string containing only the stable release versions
        from the input, with pre-release versions filtered out.

    Example:
    --------
    >>> filter_release_versions(">=1.2.3-alpha, <2.0.0")
    '>=1.2.3, <2.0.0'
    >>> filter_release_versions("!=2.0.0-rc.5.3.1")
    '!=2.0.0'
    """
    specifier_list = split_specifiers(specifiers)
    release_specifiers = []

    for spec in specifier_list:
        release_version = extract_release_version(spec)
        if release_version:
            new_spec = recreate_specifier_with_release_version(
                spec, release_version)
            release_specifiers.append(new_spec)
    return ", ".join(release_specifiers)

def get_repo_name_from_url(repo_url):
    """
    Extracts the repository name from a given repository URL.

    Parameters:
    ----------
    repo_url : str
        The full URL of the repository, which may include the ".git" extension.

    Returns:
    -------
    str
        The name of the repository extracted from the URL,
        without the ".git" extension if present.

    Example:
    --------
    >>> get_repo_name_from_url("https://github.com/user/repo.git")
    'repo'
    """
    repo_name = repo_url.rstrip("/").split("/")[-1]
    if repo_name.endswith(".git"):
        repo_name = repo_name[:-4]  # Remove '.git' extension if present
    return repo_name

def repo_exists(repo_name):
    """
    Checks if a directory with the repository name already exists.

    Parameters:
    ----------
    repo_name : str
        The name of the repository (or directory) to check for existence.

    Returns:
    -------
    bool
        True if the directory exists and is a directory, False otherwise.

    Example:
    --------
    >>> repo_exists("my-repo")
    True
    """
    return os.path.exists(repo_name) and os.path.isdir(repo_name)

def construct_authenticated_url(repo_url, username, token):
    """
    Constructs an authenticated URL by inserting the username and token.

    Parameters:
    ----------
    repo_url : str
        The original repository URL (e.g., from GitHub or Bitbucket).
    username : str
        The username for authentication.
    token : str
        The personal access token or password for authentication.

    Returns:
    -------
    str
        The authenticated URL with the username and token embedded.
    
    Example:
    --------
    >>> repo_url= "https://bitbucket.org/user/repo"
    >>> username = "username"
    >>> token = "token"
    >>> construct_authenticated_url(repo_url, username, token)
    'https://username:token@bitbucket.org/user/repo'
    """
    return repo_url.replace("https://", f"https://{username}:{token}@")

def clone_repository(authenticated_repo_url, repo_name):
    """
    Runs the git clone command to clone the repository.

    Parameters:
    ----------
    authenticated_repo_url : str
        The authenticated URL of the repository to clone.
        This URL should include the username and
        token for authentication
        (e.g., "https://username:token@bitbucket.org/user/repo").
    repo_name : str
        The name of the folder where the repository will be cloned.
        This is typically the name of the repository.

    Returns:
    -------
    None
        The function does not return a value.
        It logs success or failure of the clone operation.

    Example:
    --------
    >>> auth_repo_url = "https://username:token@bitbucket.org/user/repo"
    >>> repo_name = "repo"
    >>> clone_repository(auth_repo_url, repo_name)
    Repository cloned successfully into the current folder
    """
    try:
        subprocess.run(
            ["git", "clone", authenticated_repo_url, repo_name],
            check=True
        )

        logger.info("Repository cloned successfully into the current folder")
    except subprocess.CalledProcessError as e:
        logger.error("Error cloning repository: %s", {e})

def git_clone(repo_url, input_args):
    """
    Clones a git repository from the given URL
    into a directory named after the repository.

    Parameters:
    ----------
    repo_url : str
        The URL of the Git repository to clone (e.g., 
        "https://bitbucket.org/user/repo").
    input_args : list
        A list of input arguments.
        This should contain the following elements:
        - The script name
        - The username for proxy authentication
        - The password for proxy authentication
        - The GitHub token
        - The environment
        - The path to the credentials file
        - The Bitbucket username
        - The HTTP token

    Returns:
    -------
    None
        The function does not return a value.
        It logs information about
        the cloning process and any errors that occur.

    Example:
    --------
    >>> repo_url = "https://bitbucket.org/user/repo"
    >>> input_args = "["script.py", "username", "password",
                       "GITHUB_TOKEN", "credentials.json", "SERVER"]"
    >>> git_clone(repo_url, input_args)
    Repository cloned successfully into the current folder
    """
    repo_name = get_repo_name_from_url(repo_url)
    if repo_exists(repo_name):
        logger.info("The repository %s already exists.",repo_name)
        return

    bitbucket_username = input_args.bitbucket_user
    http_token = input_args.bitbucket_token
    authenticated_repo_url = construct_authenticated_url(
        repo_url,
        bitbucket_username,
        http_token
    )
    clone_repository(authenticated_repo_url, repo_name)

def directory_exists(path):
    """
    Checks if the specified directory exists.

    Parameters:
    ----------
    path : str
        The file system path to check for the existence of a directory.

    Returns:
    -------
    bool
        Returns True if the directory exists, otherwise returns False.

    Example:
    --------
    >>> directory_exists("/path/to/dir")
    True
    """
    return os.path.exists(path) and os.path.isdir(path)

def set_permissions_for_deletion(path):
    """
    Changes the permissions of the given path to allow deletion.

    Parameters:
    ----------
    path : str
        The file system path for which to change permissions. This should be 
        the path to a file or directory that you want to make deletable.

    Returns:
    -------
    None
        This function does not return a value. 
        It modifies the permissions of the specified path
        to allow for deletion.
    
    Example:
    --------
    >>> set_permissions_for_deletion("/path/to/file")
    """
    os.chmod(path, stat.S_IWRITE)

def delete_files_in_directory(repo_name):
    """
    Deletes all files in the specified directory.

    Parameters:
    ----------
    repo_name : str
        The name of the directory from which to delete all files.
        This should be a valid path to the repository.

    Returns:
    -------
    None
        This function does not return a value.
        It performs file deletion in the specified directory.

    Example:
    --------
    >>> delete_files_in_directory("my-repo")
    """
    for root, _, files in os.walk(repo_name, topdown=False):
        for name in files:
            file_path = os.path.join(root, name)
            set_permissions_for_deletion(file_path)
            os.remove(file_path)

def delete_subdirectories(repo_name):
    """
    Deletes all subdirectories in the specified directory.

    Parameters:
    ----------
    repo_name : str
        The name of the directory from which to delete all subdirectories. 
        This should be a valid path to the repository.

    Returns:
    -------
    None
        This function does not return a value.
        It performs the deletion of subdirectories in the specified directory.

    Example:
    --------
    >>> delete_subdirectories("my-repo")
    """
    for root, dirs, _ in os.walk(repo_name, topdown=False):
        for name in dirs:
            dir_path = os.path.join(root, name)
            set_permissions_for_deletion(dir_path)
            os.rmdir(dir_path)

def delete_main_directory(repo_name):
    """
    Deletes the main repository directory itself.

    Parameters:
    ----------
    repo_name : str
        The name of the directory to delete.
        This should be a valid path to the main repository directory.

    Returns:
    -------
    None
        This function does not return a value.
        It deletes the specified directory if it is empty.

    Example:
    --------
    >>> delete_main_directory("my-repo")
    """
    os.rmdir(repo_name)

def cleanup(repo_name):
    """
    Deletes the local folder of the cloned repository,
    including all files and directories.

    Parameters:
    ----------
    repo_name : str
        The name of the repository directory to be cleaned up.
        This should be a valid path.

    Returns:
    -------
    None
        This function does not return a value.
        It performs cleanup operations on the specified repository directory.

    Example:
    ---------
    >>> cleanup("my-repo")
    Cleaned up and deleted the repository my-repo
    """
    try:
        if directory_exists(repo_name):
            delete_files_in_directory(repo_name)
            delete_subdirectories(repo_name)
            delete_main_directory(repo_name)
            logger.info("Cleaned up and deleted the repository %s", repo_name)
        else:
            logger.info(
                "Repository %s does not exist. "
                "No cleanup needed.", 
                repo_name
            )
    except OSError as e:
        logger.error("Error during cleanup: %s", e)

def find_packages_config(root_dir):
    """
    Recursively search for 'packages.config' files in the given directory.

    Parameters:
    ----------
    root_dir : str
        The root directory in which to search for 'packages.config' files.
        This should be a valid path to a directory.

    Returns:
    -------
    list
        A list of paths (as strings) to all 'packages.config'
        files found in the directory and its subdirectories.

    Example:
    --------
    >>> find_packages_config("/path/to/project")
    ['/path/to/project/packages.config',
    '/path/to/project/subdir/packages.config']
    """
    return list(Path(root_dir).rglob("packages.config"))

def parse_packages_config(file_path):
    """
    Parse the 'packages.config' file and extract package names and versions.

    Parameters:
    ----------
    file_path : str
        The path to the 'packages.config' file to be parsed.
        This should be a valid file path.

    Returns:
    -------
    list of tuple
        A list of tuples where each tuple
        contains the package ID and its version

    Example:
    --------
    >>> parse_packages_config("/path/to/packages.config")
    [('Newtonsoft.Json', '12.0.1'), ('Serilog', '2.10.0')]
    """
    tree = ET.parse(file_path)
    root = tree.getroot()

    packages = []
    for package in root.findall("package"):
        package_id = package.get("id")
        version = package.get("version")
        packages.append((package_id, version))
    return packages

def clean_vulnerable_range(vulnerable_range):
    """
    Cleans the vulnerable range by replacing "=" with "==" if needed.

    Parameters:
    ----------
    vulnerable_range : str
        A string representing the vulnerable version range. 

    Returns:
    -------
    str
        The cleaned version of the vulnerable range,
        with "=" replaced by "==" if applicable.

    Example:
    --------
    >>> clean_vulnerable_range("=1.2.3")
    '==1.2.3'
    >>> clean_vulnerable_range("==1.2.3")
    '==1.2.3'
    """
    pattern = r"^=\s*(\d+(\.\d+)?)"
    match = re.match(pattern, str(vulnerable_range))

    if match is not None and "," not in vulnerable_range:
        return vulnerable_range.replace("=", "==")
    return vulnerable_range

def is_valid_version_and_specifier(installed_version, vulnerable_range):
    """
    Validates the installed version
    and vulnerable range against the regex patterns.

    Parameters:
    ----------
    installed_version : str
        The version of the installed package to be validated.

    vulnerable_range : str
        The string representing the vulnerable version range to be validated.

    Returns:
    -------
    bool
        True if both the installed version and
        vulnerable range are valid, otherwise False.

    Example:
    --------
    >>> is_valid_version_and_specifier("1.2.3", ">=1.0.0,<2.0.0")
    True
    >>> is_valid_version_and_specifier("1.2.3", ">=1.0.0,<2.0.0-preview-2.3.1")
    False
    """
    specifier_set_regex = re.compile(
        r"""
            ^\s*
            (?P<specifiers>
                (
                    (?P<operator>[<>!=]=?|~)?
                    \s*
                    (?P<epoch>[0-9]+!)?
                    (?P<release>[0-9]+(\.[0-9]+)*)
                    (?P<pre>[-_.]?(a|b|rc|preview)\d*)?
                    (?P<post>(?:-(\d+))|(?:[-_.]?(post|rev|r)\d+))?
                    (?P<dev>[-_.]?dev\d+)?
                    (?:\+[a-z0-9]+(?:[-_.][a-z0-9]+)*)?
                )
                (?:\s*,\s*
                    (
                        (?P<operator2>[<>!=]=?|~)?
                        \s*
                        (?P<epoch2>[0-9]+!)?
                        (?P<release2>[0-9]+(\.[0-9]+)*)
                        (?P<pre2>[-_.]?(a|b|rc|preview)\d*)?
                        (?P<post2>(?:-(\d+))|(?:[-_.]?(post|rev|r)\d+))?
                        (?P<dev2>[-_.]?dev\d+)?
                        (?:\+[a-z0-9]+(?:[-_.][a-z0-9]+)*)?
                    )*
                )*
            )
            \s*$
        """,
        re.VERBOSE | re.IGNORECASE,
    )

    version_regex = re.compile(
        r"""
        ^
        (?P<epoch>[0-9]+!)?
        (?P<release>[0-9]+(\.[0-9]+)*)
        (?P<pre>[-_.]?(a|b|rc|preview)\d*)?
        (?P<post>(?:-(\d+))|(?:[-_.]?(post|rev|r)\d+))?
        (?P<dev>[-_.]?dev\d+)?
        (?:\+[a-z0-9]+(?:[-_.][a-z0-9]+)*)?$
        """,
        re.VERBOSE | re.IGNORECASE,
    )
    return (
        specifier_set_regex.match(str(vulnerable_range)) and
        version_regex.match(str(installed_version))
    )

def check_version_in_range(installed_version, vulnerable_range):
    """
    Checks if the installed version is within the vulnerable range.

    Parameters:
    ----------
    installed_version : str
        The version of the installed package to be checked.

    vulnerable_range : str
        The string representing the vulnerable version range.

    Returns:
    -------
    bool
        True if the installed version is within the specified vulnerable range, 
        otherwise False.

    Example:
    -------
    >>> check_version_in_range("1.2.3", ">=1.0.0,<2.0.0")
    True
    >>> check_version_in_range("1.2.3", ">=1.0.0,<1.2.3")
    False
    """
    specifiers = SpecifierSet(str(vulnerable_range), prereleases=True)
    version_to_check = Version(str(installed_version))
    return specifiers.contains(version_to_check)

def is_version_vulnerable(installed_version, vulnerable_range):
    """
    Determines if the installed version is vulnerable by comparing it with the
    vulnerable version range.

    Parameters:
    ----------
    installed_version : str
        The version of the installed package to be evaluated.

    vulnerable_range : str
        The string representing the vulnerable version range.

    Returns:
    -------
    str
        Returns 'True' if the installed version is vulnerable, 
        'False' if it is not, or 'False-manual' if the format wasn't standard.

    Example:
    --------
    >>> is_version_vulnerable('1.0.0', '>=0.9.0,<1.1.0')
    'True'

    >>> is_version_vulnerable('1.0.0', '>=0.9.0,<1.0.0')
    'False'

    >>> is_version_vulnerable('2.0.0', '>=1.5.0,<2.0.0-rc-3.6.2')
    'False-manual'
    """
    # Clean the vulnerable range if needed
    vulnerable_range = clean_vulnerable_range(vulnerable_range)

    # Validate the installed version and vulnerable range formats
    if is_valid_version_and_specifier(installed_version, vulnerable_range):
        # Check if the version is within the specified range
        return str(check_version_in_range(installed_version, vulnerable_range))

    # If the format isn't standard, filter the release versions manually
    specifiers = SpecifierSet(
        str(filter_release_versions(vulnerable_range)), prereleases=True
    )
    version_to_check = Version(str(installed_version))
    return str(specifiers.contains(version_to_check)) + "-manual"

def prepare_graphql_query():
    """
    Prepares the GraphQL query string for fetching vulnerabilities.
    """
    return """
    query($package: String!, $after: String) {
      securityVulnerabilities(ecosystem: NUGET, package: $package, first: 100, after: $after) {
        nodes {
          severity
          vulnerableVersionRange
          advisory {
            summary
            description
          }
          firstPatchedVersion {
            identifier
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
    """

def setup_request_parameters(package_name, environment, proxy, github_token):
    """
    Sets up the request parameters including variables, headers, and proxies.

    Parameters:
    ----------
    package_name : str
        The name of the package for which the request is being set up.

    environment : str
        The environment string ('LOCAL' or 'SERVER')
        used to determine the proxy settings.

    proxy : dict
        A dictionary mapping environments to their respective proxy URLs.

    github_token : str
        The GitHub authorization token used for the request headers.

    Returns:
    -------
    tuple
        A tuple containing:
        - dict: Variables for the request, including the package name.
        - dict: Proxies for HTTP and HTTPS requests based
                on the specified environment.
        - dict: Headers for the request, including
                the authorization token and content type.

    Example:
    --------
    >>> proxy = {'LOCAL': 'http://localhost:8080',
                 'SERVER': 'http://dev.proxy:8080'}
    >>> setup_request_parameters('MyPackage', 'LOCAL', proxy, 'my_token')
    ({'package': 'MyPackage', 'after': None},
     {'http': 'http://localhost:8080', 'https': 'http://localhost:8080'},
     {'Authorization': 'bearer my_token', 'Content-Type': 'application/json'})
    """
    variables = {"package": package_name, "after": None}
    proxies = {"http": proxy[environment], "https": proxy[environment]}
    headers = {
        "Authorization": f"bearer {github_token}",
        "Content-Type": "application/json"
    }
    return variables, proxies, headers

def execute_graphql_query(query, variables, headers, proxies):
    """
    Executes the GraphQL query and returns the vulnerabilities data.

    Parameters:
    ----------
    query : str
        The GraphQL query string to be executed.

    variables : dict
        A dictionary of variables to be included in the GraphQL query,
        including the package name.

    headers : dict
        A dictionary of headers to be sent with the request,
        typically including authorization.

    proxies : dict
        A dictionary mapping HTTP and HTTPS requests
        to their respective proxy URLs.

    Returns:
    -------
    list
        A list of vulnerability data nodes
        returned from the GraphQL query, each containing information 
        about vulnerabilities associated with the specified package.

    Raises:
    ------
    ConnectionError
        If the request fails or if there are errors in the GraphQL response.

    Example:
    --------
    >>> query = prepare_graphql_query()
    >>> variables = {'package': 'MyPackage', 'after': None}
    >>> headers = {'Authorization': 'bearer my_token'}
    >>> proxies = {'http': 'http://localhost:8080',
                   'https': 'http://localhost:8080'}
    >>> execute_graphql_query(query, variables, headers, proxies)
    [{'severity': 'HIGH', 'vulnerableVersionRange': '>=1.0.0,<1.2.0', ...}]
    """
    response = requests.post(
        "https://api.github.com/graphql",
        json={"query": query, "variables": variables},
        headers=headers,
        proxies=proxies,
        timeout=60,
    )

    if response.status_code != 200:
        raise ConnectionError(
            f"Query failed with status code {response.status_code}. "
            f"{response.text}"
        )

    result = response.json()
    if "errors" in result:
        raise ConnectionError(f"GraphQL errors: {result['errors']}")
    return result["data"]["securityVulnerabilities"]["nodes"]


def query_github_vulnerabilities(package_name, input_data, params):
    """
    Queries GitHub's GraphQL API for
    known vulnerabilities in the given package.

    Parameters:
    ----------
    package_name : str
        The name of the package for which to query vulnerabilities.

    input_data : dict
        A dictionary containing the proxy settings for the environment.

    params : list
        A list of parameters including user credentials and the environment. 

    Returns:
    -------
    list
        A list of vulnerability data nodes returned from the GraphQL query,
        each containing information about known vulnerabilities associated 
        with the specified package.

    Example:
    --------
    >>> input_data = {'proxy': {'LOCAL': 'http://localhost:8080',
                                 'SERVER': 'http://dev.proxy:8080'}
                     }
    >>> params = ["script.py", "USERNAME", "PASSWORD",
                 "GITHUB_TOKEN", "credentials.json", "SERVER"]
    >>> query_github_vulnerabilities('MyPackage', input_data, params)
    [{'severity': 'HIGH', 'vulnerableVersionRange': '>=1.0.0,<1.2.0', ...}]
    """
    github_token = params.git_token
    proxy = input_data["proxy"]
    query = prepare_graphql_query()

    # Setup request parameters
    variables, proxies, headers = setup_request_parameters(
        package_name, params.environment, proxy, github_token
    )

    # Fetch vulnerabilities
    all_vulnerabilities = execute_graphql_query(
        query,
        variables,
        headers,
        proxies
    )
    return all_vulnerabilities

def sort_vulnerabilities_by_severity(vulnerabilities, severity_order):
    """
    Sorts the list of vulnerabilities based on severity.

    Parameters:
    ----------
    vulnerabilities : list
        A list of dictionaries, each containing information
        about a vulnerability, specifically the 'severity' key.

    severity_order : list
        A list that defines the order of severity levels, where a lower index 
        indicates a higher priority in sorting 
        (e.g., ['CRITICAL', 'HIGH', 'MODERATE', 'LOW']).

    Returns:
    -------
    list
        A sorted list of vulnerabilities,
        arranged according to the specified severity order.

    Example:
    --------
    >>> vulnerabilities = [{'severity': 'LOW'},
                           {'severity': 'CRITICAL'},
                           {'severity': 'MODERATE'}]
    >>> sort_vulnerabilities_by_severity(vulnerabilities,
                                        ['CRITICAL', 'HIGH',
                                        'MODERATE', 'LOW'])
    [{'severity': 'CRITICAL'}, {'severity': 'MODERATE'}, {'severity': 'LOW'}]
    """
    return sorted(
    vulnerabilities,
    key=lambda x: severity_order.index(x["severity"])
    )


def is_vulnerability_applicable(package_version, vulnerability):
    """
    Checks if a package version is vulnerable
    and if the advisory is not a duplicate.

    Parameters:
    ----------
    package_version : str
        The version of the package to be checked for vulnerabilities.

    vulnerability : dict
        A dictionary containing information about the vulnerability,
        specifically:
        - 'vulnerableVersionRange': A string that specifies the range of
          vulnerable versions.
        - 'advisory': A dictionary containing the advisory details, including
          a 'summary' key that describes the advisory.

    Returns:
    -------
    bool
        Returns True if the package version is vulnerable and the advisory
        is not a duplicate, or False otherwise.

    Example:
    --------
        >>> package_version = "1.0.0"
        >>> vulnerability = {
                "vulnerableVersionRange": ">=1.0.0,<2.0.0",
                "advisory": {"summary": "Security fix in version 2.0.0"}
            }
        >>> is_vulnerability_applicable(package_version, vulnerability)
        True

        >>> package_version = "1.0.0"
        >>> vulnerability = {
                "vulnerableVersionRange": ">=1.0.0,<2.0.0",
                "advisory": {"summary": "Duplicate: Security fix
                                         in version 2.0.0"}
            }
        >>> is_vulnerability_applicable(package_version, vulnerability)
        False
    """
    vulnerable_range = vulnerability["vulnerableVersionRange"]
    is_vulnerable = (
        is_version_vulnerable(
           package_version,
           vulnerable_range
        ).replace("-manual", "")
        == "True"
    )
    is_not_duplicate = "Duplicate" not in vulnerability["advisory"]["summary"]
    return is_vulnerable and is_not_duplicate

def log_vulnerability_header(file_to_check, result_file_name):
    """
    Logs the header information about
    the vulnerabilities found in the output file.

    Parameters:
    ----------
    file_to_check : str
        The path to the input file that was checked for vulnerabilities.

    result_file_name : str
        The name of the output file where
        the header information will be logged.

    Returns:
    -------
    None
        This function does not return a value.
        It appends header information to the specified output file.

    Example:
    --------
        >>> file = "path/to/packages.config"
        >>> output_file_name = "vulnerability_report.txt"
        >>> log_vulnerability_header(file, output_file_name)
    """
    with open(result_file_name, "a", encoding="utf-8") as out_file:
        out_file.writelines(f"  Vulnerabilities found for {file_to_check}:\n")

def log_manual_verification_warning(result_file_name):
    """
    Logs a manual verification warning
    if the vulnerability check was not standard.

    Parameters:
    ----------
    result_file_name : str
        The name of the output file where the warning message will be logged.

    Returns:
    -------
    None
        This function does not return a value.
        It appends a warning message to the specified output file.

    Example:
    --------
        >>> log_manual_verification_warning("vulnerability_report.txt")
    """
    with open(result_file_name, "a", encoding="utf-8") as out_file:
        out_file.writelines(
            "      WARNING: The following check was not performed using"
            " the Python library, so it's recommended to manually verify"
            " if the version is vulnerable.\n"
        )

def log_vulnerability_details(
    package_name,
    package_version,
    vulnerability,
    result_file_name
):
    """
    Logs the details of a specific vulnerability to the output file.

    Parameters:
    ----------
    package_name : str
        The name of the package that is vulnerable.

    package_version : str
        The version of the package that is being evaluated.

    vulnerability : dict
        A dictionary containing details about the vulnerability,
        including severity, advisory summary, vulnerable version range,
        and first patched version.

    result_file_name : str
        The name of the output file where the vulnerability
        details will be logged.
    
    Example:
    --------
        >>> vulnerability = {
                "severity": "HIGH",
                "advisory": {"summary": "Security vulnerability found"},
                "vulnerableVersionRange": ">=1.0.0,<2.0.0",
                "firstPatchedVersion": {"identifier": "2.0.0"}
            }
        >>> output_file_name = "vulnerability_report.txt"
        >>> package_name = "Newtonsoft.Json"
        >>> version = "1.0.0"
        >>> log_vulnerability_details(package_name, version,
                                      vulnerability, output_file_name)
    """
    with open(result_file_name, "a", encoding="utf-8") as out_file:
        out_file.writelines(
            f"      Package: {package_name}, "
            f"Version: {package_version}\n"
        )
        out_file.writelines(
            f"      Severity: {vulnerability['severity']}\n"
        )
        out_file.writelines(
            f"      Advisory: {vulnerability['advisory']['summary']}\n"
        )
        vulnerable_version_range = vulnerability['vulnerableVersionRange']
        out_file.writelines(
            f"      Vulnerable Version Range: {vulnerable_version_range}\n"
        )
        out_file.writelines(
            "      First patched version: "
            f"{vulnerability['firstPatchedVersion']['identifier']}\n\n"
        )

def check_vulnerabilities(
    file_to_check,
    input_args,
    input_data,
    result_file_name
):
    """
    Checks for vulnerabilities in
    each package listed in 'packages.config'
    and logs the details.

    Parameters:
    ----------
    file_to_check : str
        The path to the 'packages.config' file that contains the list
        of packages to be checked for vulnerabilities.

    input_args : list
        A list of input arguments including credentials and configuration
        details for GitHub API access.

    input_data : dict
        A dictionary containing relevant input data, including sender and
        receiver email addresses, output file name, project sources, and
        proxy settings.

    result_file_name : str
        The name of the output file where
        the vulnerability details will be logged.

    Returns:
    -------
    None
        This function does not return a value. It processes the packages,
        checks for vulnerabilities, and logs the findings to the specified
        output file.

    Example:
    --------
        >>> file_path="path/to/packages.config"
        >>> out_file_name = "vulnerability_report.txt"
        >>> input_args=['script.py', 'USERNAME', 'PASSWORD',
                        'GITHUB_TOKEN', 'LOCAL',
                        'path/to/credentials.json', 'GIT_USER', 'GIT_TOKEN']
        >>> input_data = {
            'sender': 'sender@example.com',
            'receivers': ['receiver1@example.com', 'receiver2@example.com'],
            'output_file_name': 'vulnerabilities',
            'projects_sources': [
                'https://github.com/user/project1',
                'https://github.com/user/project2'
            ],
            'smtp_host': 'smtp.domain.com',
            'smtp_port': 587,
            'proxy': {
                'SERVER': 'dev.proxy.domain.com',
                'LOCAL': 'localhost:8080'
            }
        >>> out_file_name = "vulnerabilities.txt"
        >>> check_vulnerabilities(file_path, input_args,
                                  input_data, out_file_name)
    """
    packages = parse_packages_config(file_to_check)
    header_logged = False
    severity_order = ["CRITICAL", "HIGH", "MODERATE", "LOW"]

    for package_name, package_version in packages:
        vulnerabilities = query_github_vulnerabilities(
            package_name,
            input_data,
            input_args
        )
        sorted_vulnerabilities = sort_vulnerabilities_by_severity(
            vulnerabilities,
            severity_order
        )

        for vulnerability in sorted_vulnerabilities:
            if is_vulnerability_applicable(package_version, vulnerability):
                if not header_logged:
                    log_vulnerability_header(file_to_check, result_file_name)
                    header_logged = True
                vulnerable_version_range = (
                    vulnerability["vulnerableVersionRange"]
                )

                is_vulnerable = is_version_vulnerable(
                    package_version,
                    vulnerable_version_range
                )
                if "-manual" in is_vulnerable:
                    log_manual_verification_warning(result_file_name)
                log_vulnerability_details(
                package_name,
                package_version,
                vulnerability,
                result_file_name
                )

def create_email(input_data, output_files):
    """
    Create an email message with the specified attachments.

    Parameters:
    ----------
    input_data : dict
        A dictionary containing relevant input data, including sender and
        receiver email addresses, output file name, project sources
        and proxy settings.

    output_files : list of str
        A list of file paths to be attached to the email.

    Returns:
    -------
    tuple
        A tuple containing the constructed email message
        as a MIMEMultipart object and a boolean indicating
        whether the email should be sent.

    Example:
    --------
        >>> input_data = {
            'sender': 'sender@example.com',
            'receivers': ['receiver1@example.com', 'receiver2@example.com'],
            'output_file_name': 'vulnerabilities',
            'projects_sources': [
                'https://github.com/user/project1',
                'https://github.com/user/project2'
            ],
            'smtp_host': 'smtp.domain.com',
            'smtp_port': 587,
            'proxy': {
                'SERVER': 'dev.proxy.domain.com',
                'LOCAL': 'localhost:8080'
            }
        >>> output_files = ["vulnerabilities-project1.txt",
                            "vulnerabilities-project2.txt"]
        >>> message, should_send_email = create_email(input_data, output_files)
        >>> should_send_email
        True

        >>> input_data = {
            'sender': 'sender@example.com',
            'receivers': ['receiver1@example.com', 'receiver2@example.com'],
            'output_file_name': 'vulnerabilities',
            'projects_sources': [
                'https://github.com/user/project1',
                'https://github.com/user/project2'
            ],
            'smtp_host': 'smtp.domain.com',
            'smtp_port': 587,
            'proxy': {
                'SERVER': 'dev.proxy.domain.com',
                'LOCAL': 'localhost:8080'
            }
        >>> output_files = []
        >>> message, should_send_email = create_email(input_data, output_files)
        >>> should_send_email
        False
    """
    message = MIMEMultipart()
    message["From"] = input_data["sender"]
    message["To"] = ", ".join(input_data["receivers"])
    message["Subject"] = "Seek NuGet vulnerabilities"

    body = "Hello!\n\nWe've detected some .NET vulnerabilities in "
    should_send_email = False

    # Attach the files
    for file_to_attach in output_files:
        if attach_file_to_email(message, file_to_attach):
            project_name = (
                file_to_attach
                .replace("vulnerabilities-", "")
                .replace(".txt", "")
            )
            body += project_name + "; "
            should_send_email = True

    body += "\n\nPlease check the attached file(s) for more details.\n"
    message.attach(MIMEText(body, "plain"))
    return message, should_send_email

def attach_file_to_email(message, file_to_attach):
    """
    Attach a file to the email message.
    Returns True if the file was successfully attached, False otherwise.

    Parameters:
    ----------
    message : MIMEMultipart
        The email message object to which the file will be attached.

    file_to_attach : str
        The path of the file to be attached.

    Returns:
    -------
    bool
        Returns True if the file was successfully attached, 
        False if the file is empty or could not be attached.

    Example:
    --------
        >>> message = MIMEMultipart()
        >>> attach_file_to_email(message, "vulnerabilities-project1.txt")
        True
    """
    attachment = MIMEBase("application", "octet-stream")
    with open(file_to_attach, "rb") as f:
        file_content = f.read().strip()
        if file_content == b"":  # Skip empty files
            return False
        attachment.set_payload(file_content)

    # Encode and add header to the attachment
    encoders.encode_base64(attachment)
    attachment.add_header(
        "Content-Disposition",
        f"attachment; filename={os.path.basename(file_to_attach)}",
    )
    message.attach(attachment)
    return True

def send_email_with_retries(message, input_data, arguments, max_retries=3):
    """
    Send the email with a retry mechanism.

    Parameters:
    ----------
    message : MIMEMultipart
        The email message object to be sent.

    input_data : dict
        A dictionary containing SMTP configuration and sender information: 
        email sender, receivers, output file name,
        project sources, SMTP host, SMTP port, and proxy configurations

    arguments : list
        A list of input arguments including credentials and configuration
        details for GitHub API access.

    max_retries : int, optional
        The maximum number of retry attempts to send the email (default is 3).

    Returns:
    -------
    None

    Example:
    --------
            >>> message = MIMEMultipart()
            >>> input_data = {
                    'smtp_host': 'smtp.domain.com',
                    'smtp_port': 587,
                    'sender': 'example@domain.com',
                    'receivers': ['receiver@domain.com']
                }
            >>> arguments = ["script.py", "USERNAME", "PASSWORD",
                             "GITHUB_TOKEN", "credentials.json", "SERVER"]
            >>> send_email_with_retries(message, input_data,
                                        arguments, max_retries=3)
    """
    for attempt in range(max_retries):
        try:
            # Send the email
            logger.info("Attempt %d to send email...",attempt + 1)
            server = smtplib.SMTP(
                host=input_data["smtp_host"],
                port=input_data["smtp_port"]
            )
            server.starttls()
            server.login(arguments.sys_username, arguments.sys_password)
            server.sendmail(
                from_addr=input_data["sender"],
                to_addrs=input_data["receivers"],
                msg=message.as_string()
            )
            logger.info("Email sent successfully!")
            break  # Exit the loop if the email is sent successfully
        except (ConnectionError, smtplib.SMTPException) as e:
            logger.error("Error on attempt %d: %s", attempt + 1,e)
            if attempt < max_retries - 1:
                logger.info("Retrying in 5 seconds...")
                time.sleep(5)
            else:
                logger.error("Max retries reached. Failed to send email.")
        finally:
            try:
                server.quit()
            except smtplib.SMTPException as e:
                logger.error("Error while quitting the server: %s",e)

def send_vulnerability_report(output_files, arguments, credentials_file_path):
    """
    Manages the process of sending a vulnerability report via email.

    Parameters:
    ----------
    output_files : list
        A list of file names containing the vulnerability reports
        to be attached to the email.

    arguments : list
        A list of input arguments including
        credentials and configuration details for GitHub API access.

    credentials_file_path : str
        The file path to the JSON file containing
        the input data for sending the email.

    Returns:
    -------
    None

    Example:
    --------
        >>> output_files = ["vulnerabilities-project1.txt",
                            "vulnerabilities-project2.txt"]
        >>> arguments = ["script.py", "username", "password",
                         "GITHUB_TOKEN", "credentials.json", "SERVER"]
        >>> input_file = "credentials.json"
        >>> send_vulnerability_report(output_files, arguments, input_file)
    """
    input_data = load_credentials(credentials_file_path)
    message, should_send_email = create_email(input_data, output_files)

    if should_send_email:
        send_email_with_retries(message, input_data, arguments)
    else:
        logger.info("No vulnerabilities detected!")

def load_credentials(credentials_file_path):
    """
    Load credentials data from the specified JSON file.

    Parameters:
    ----------
    credentials_file_path : str
        The path to the JSON file containing credentials data.

    Returns:
    -------
    dict
        A dictionary containing the loaded credentials with the following keys:
        - 'sender': str
            The email address of the sender.
        - 'receivers': list
            A list of email addresses for the receivers.
        - 'output_file_name': str
            The base name for the output files.
        - 'projects_sources': list
            A list of project source URLs.
        - 'smtp_host': str
            The SMTP server host.
        - 'smtp_port': int
            The SMTP server port.
        - 'proxy': dict
            A dictionary mapping environments to proxy URLs.

    Raises:
    ------
    FileNotFoundError
        If the specified JSON file does not exist.
    json.JSONDecodeError
        If the file contents cannot be decoded as valid JSON.

    Example:
    --------
        >>> credentials = load_credentials("credentials.json")
        >>> credentials
        {
            'sender': 'sender@example.com',
            'receivers': ['receiver1@example.com', 'receiver2@example.com'],
            'output_file_name': 'vulnerabilities',
            'projects_sources': [
                'https://github.com/user/project1',
                'https://github.com/user/project2'
            ],
            'smtp_host': 'smtp.domain.com',
            'smtp_port': 587,
            'proxy': {
                'SERVER': 'dev.proxy.domain.com',
                'LOCAL': 'localhost:8080'
            }
        }
    """
    with open(credentials_file_path, "r", encoding="utf-8") as file:
        return json.load(file)

def process_projects(projects_sources, args, data_input, output_files_list):
    """
    Process each project to clone, check vulnerabilities, and clean up.

    Parameters:
    ----------
    projects_sources : list
        A list of project source URLs to be processed.

    args : list
        A list of input arguments including credentials and configuration
        details for GitHub API access.

    data_input : dict
        A dictionary containing relevant input data, including sender and
        receiver email addresses, output file name, project sources
        and proxy settings.

    output_files_list : list
        A list to store the names of output files generated
        during the processing of projects.

    Returns:
    -------
    None
        This function does not return a value.
        It modifies the output_files_list in place.

    Example:
    --------
        >>> projects_sources = ["https://github.com/user/project1",
                                "https://github.com/user/project2"]
        >>> args = ["script.py", "username", "password",
                    "GITHUB_TOKEN", "credentials.json", "SERVER"]
        >>> data_input = {"output_file_name": "vulnerabilities-report"}
        >>> output_files_list = []
        >>> process_projects(projects_sources, args,
                            data_input, output_files_list)
    """
    for project in projects_sources:
        process_project(project, args, data_input, output_files_list)

def process_project(project, args, data_input, output_files_list):
    """
    Process an individual project:
    clone, check for vulnerabilities, and clean up.
    
    Parameters:
    ----------
    project : str
        The URL of the GitHub project to be processed.

    args : list
        A list of input arguments including credentials and configuration
        details for GitHub API access.

    data_input : dict
        A dictionary containing relevant input data, including sender and
        receiver email addresses, output file name, project sources
        and proxy settings.

    output_files_list : list
        A list to store the names of output files generated
        during the processing of the project.

    Returns:
    -------
    None
        This function does not return a value.
        It modifies the output_files_list in place.

    Example:
    --------
        >>> project = "https://github.com/user/project1"
        >>> args = ["script.py", "username", "password",
                    "GITHUB_TOKEN", "credentials.json", "SERVER"]
        >>> data_input = {"output_file_name": "vulnerabilities-report"}
        >>> output_files_list = []
        >>> process_project(project, args, data_input, output_files_list)
    """
    output_file_name = data_input["output_file_name"]
    git_clone(project, args)

    output_file_name = (
        f"{output_file_name}-"
        f"{get_repo_name_from_url(project)}.txt"
    )
    output_files_list.append(output_file_name)

    create_output_file(output_file_name)

    # Find all 'packages.config' files in the project directory
    packages_files = find_packages_config(get_repo_name_from_url(project))

    # Check vulnerabilities for each package in each 'packages.config' file
    for package_file in packages_files:
        check_vulnerabilities(package_file, args, data_input, output_file_name)

    cleanup(get_repo_name_from_url(project))

def create_output_file(output_file_name):
    """
    Create an empty output file.

    Parameters:
    ----------
    output_file_name : str
        The name of the output file to be created.

    Returns:
    -------
    None
        This function does not return any value.
        It simply creates the specified file.

    Example:
    --------
        >>> create_output_file("vulnerabilities-project1.txt")
    """
    with open(output_file_name, "w", encoding="utf-8"):
        pass

def clean_up_files(output_files_list):
    """
    Remove the generated output files.

    Parameters:
    ----------
    output_files_list : list of str
        A list containing the names of the output files to be removed.

    Returns:
    -------
    None
        This function does not return any value.
        It simply attempts to delete each file in the list.

    Example:
    --------
        >>> output_files_list = ["vulnerabilities-project1.txt",
                                 "vulnerabilities-project2.txt"]
        >>> clean_up_files(output_files_list)
    """
    for output_file in output_files_list:
        os.remove(output_file)

def main():
    """
    Main function to run the entire vulnerability scanning process.
    """

    parser = argparse.ArgumentParser(
    description="Vulnerability Detection Tool")
    # Define the arguments with their names

    parser.add_argument("--sys_username",
                         type=str,
                         required=True,
                         help="Proxy username for authentication")
    parser.add_argument("--sys_password",
                         type=str,
                         required=True,
                         help="Proxy password for authentication")
    parser.add_argument("--git_token",
                         type=str,
                         required=True,
                         help="GitHub token for access")
    parser.add_argument("--environment",
                         type=str,
                         required=True,
                         choices=["LOCAL", "SERVER"],
                         help="Environment to use")
    parser.add_argument("--input_file_path",
                         type=str,
                         required=True,
                         help="Path to the input file")
    parser.add_argument("--bitbucket_user",
                         type=str,
                         required=True,
                         help="BitBucket user for access")
    parser.add_argument("--bitbucket_token",
                         type=str,
                         required=True,
                         help="BitBucket token for access")
    args = parser.parse_args()

    # Load credentials
    credentials_file_path = args.input_file_path
    data_input = load_credentials(credentials_file_path)

    # Process each project
    output_files_list = []
    projects_sources = data_input["projects_sources"]
    process_projects(projects_sources, args, data_input, output_files_list)

    # Send the vulnerability report
    send_vulnerability_report(output_files_list, args, credentials_file_path)

    # Clean up generated output files
    clean_up_files(output_files_list)

if __name__ == "__main__":
    main()
